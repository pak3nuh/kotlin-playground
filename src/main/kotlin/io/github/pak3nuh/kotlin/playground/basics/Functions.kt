package io.github.pak3nuh.kotlin.playground.basics

import java.time.LocalTime
import java.time.format.DateTimeFormatter

/* -------- Glossary
* * Parameter: The input parameters that are defined in the function
* * Argument: A materialized parameter when the function is called
* * Type parameter: A generic type parameter
* * Receiver: The `this` value in the current function or function type
* * Return type: The type of the return value
*/

/*-------- Functions
* Functions are well known at this day and age and I consider them to be the first step to decouple and abstract.
* We use functions to break larger pieces of code into smaller manageable chunks that follow a specific contract
* and are expected to behave in a predicable fashion, much like an interface.
*
* Kotlin treats functions as powerful first class citizens by embedding them in the type system. We can declare functions
* and pass them around as ony other object. That is why Kotlin is considered to be a language with
* functional capabilities.
*
*
* -------- Declaration
* To declare a function we use the keyword `fun` followed by the name, parameters and the return type. The return
* type can be omitted and is a non returning function.
*/
fun concatenate(first: String, second: String): String {
    return first + second
}
fun printString(string: String): Unit {
    print(string)
}
/*
* Kotlin replaces `void` with `Unit`. The key difference is that while void returns nothing, Unit is an `object`
* declaration, meaning there is only a single instance, which the kotlin compiler manages.
* In practice all functions return something which is a very nice generalization that becomes apparent when we define
* generic functions. In this case we don't need to define a non returning specialization of the function.
* For instance Java's `Consumer` and `Function` can all be represented by Kotlin's `Function1`.
* */

/*-------- Function types
* Since functions are deeply embedded into the type system we get a special syntax to handle them, called function types.
*
* To declare a function type we just define the contract in the form of `[Receiver.](ParamType1, ParamType2) -> ReturnType`.
* To invoke such functions we can use the operator `()` or call the `invoke` method.
* The receiver is optional such as `Unit` return types.
*
* We can create instances of functions (lambdas) by wrapping the function body in brackets `{ }`. If the function
* is to have a single parameter, it can be omitted and is referenced by `it`. Otherwise they can all be explicitly
* declared after the opening bracket.
*
* Because in Kotlin anything wrapped in brackets in an expression, the return value is the last expression in the
* body. Return statements are allowed but need to be followed by a label.
*
* @implNote
* If we access the generated bytecode we can see that type functions are in fact instances of FunctionX objects,
* being X the actual number of arguments it receives. The compiler then bridges all the gaps.
* This is why the have a type checked `invoke` method on each function argument.
* */
// Lambda function example
val squareFunction: (Int) -> Int = { it * 2 }
val squareOfThree = squareFunction(3)

// Function type example
fun <T> invoker(loader: () -> T): T {
    check(loader is Function0) // always true
    println("invoking function")
    val result = loader()
    println("finished invocation")
    return result
}
val invocationValue = invoker({ "Hello" })

// Function type with receiver example
fun <T> withTime(timeFunc: LocalTime.() -> T): T {
    val time = LocalTime.now()
    return timeFunc(time)
}
val currentTimeAsIso = withTime({ this.format(DateTimeFormatter.ISO_TIME) })

/*
* Functions can be defined in any level of the file. We can have top level functions like the ones above and we can
* define functions inside any other construct like classes or interfaces.
*
* Kotlin also allow nested local functions. Unlike Java, captured scope of functions (closures) are mutable. When
* coupled together, these two features can be very helpful to solve problems that otherwise would require anonymous
* classes and other boilerplate.
* In practice, all that boilerplate is still generated, but it is hidden from the programmer.
*/
fun retry(times: Int, action: () -> Unit) {
    require(times > 0)
    var retryCounter = 0 // captured mutable closure
    fun execute(remaining: Int) {
        if (remaining < 0)
            return
        try {
            action()
        } catch (ex: Exception) {
            retryCounter++
            execute(remaining - 1)
        }
    }
    execute(times)
    println("Function retried $retryCounter times")
}
/*
* Because you are a keen programmer you will say that recursive can exhaust the stack if abused. You would argue that
* iterative solutions are sometimes cumbersome to read because of all the mutable state.
* Fortunately Kotlin helps solve this issue at the language level by adding the `tailrec` modifier. A tail recursive
* function is a function that looks recursive but the compiler writes it as iterative.
*
* For a tail recursive function to be valid, then the last expression executed (tail) must be a recursive call.
* Lets reimplement the retry function as tail recursive
*/
tailrec fun retryTailRec(times: Int, action: () -> Unit) {
    if (times <= 0)
        return

    val nextTimes = try {
        action()
        0
    } catch (ex: Exception) {
        times - 1
    }

    retryTailRec(nextTimes, action)
}
/*
* Next modifier available for functions is `inline`. This modifier works as you'd expect, inlining all function calls
* with the function content.
* This modifier should be used with caution because the function inlining may bring nothing more than increased
* app size.
*
* It usually is useful when there is some kind of function literal is passed. In this case we can optimize the call
* site by wrapping code we provide with the inline function body.
*
* */
inline fun <T> timed(action: () -> T): T {
    val start = System.currentTimeMillis()
    val result = action()
    val end = System.currentTimeMillis() - start
    println("Function call took $end milliseconds")
    return result
}
/*
* Inline functions support some of modifiers in the function parameters, like `crossinline`, but it falls out of scope
* of this tutorial.
*
* The only modifier that we are going to exemplify is `reified`. Much like Java, Kotlin bytecode is type erased after
* compiled. The language offers reified functions that can access the type parameters inside the inline function body.
* */
inline fun <reified T> safeCast(any: Any): T? {
    // this is the same as 'any as? T'
    return if (T::class.isInstance(any))
        any as T
    else
        null
}
/*-------- Type safe builders
* This one is a personal favourite of mine.
*
* In Kotlin, if the last parameter of a function is some kind of callable (function type, SAM conversion or fun interface)
* it can be extracted outside of the parenthesis.
*
* This is the key item that make Kotlin very DSL friendly.
*/

// Transmogrifier implemented with several callable types available
class CallableTransmogrifier {
    // SAM interface
    private val capitalizer = java.util.function.Function<Char, Char> { it.plus(' '.toInt()) }
    // Fun interface
    private fun interface Splitter {
        fun split(input: String): CharArray
    }
    private val splitter = Splitter { it.toCharArray() }
    // Function type
    private val rebuilder: (CharArray) -> String = { String(it) }

    fun transmogrify(input: String): String {
        return rebuilder(splitter.split(input).map { capitalizer.apply(it) }.toCharArray())
    }
}

// Same as CallableTransmogrifier but using only funtion types
class KotlinTransmogrifier {
    private val capitalizer: (Char) -> Char = { it.plus(' '.toInt()) }
    private val splitter: (String) -> CharArray = { it.toCharArray() }
    private val rebuilder: (CharArray) -> String = { String(it) }

    fun transmogrify(input: String): String {
        return rebuilder(splitter(input).map { capitalizer(it) }.toCharArray())
    }
}

/* -------- Extension functions
* Extension functions work the same way that every other language. We can define functions that look like part of the
* object's API, but are defined outside of that object class or interface.
*
* This makes sense when we think we want to keep our public API as clean and concise as possible. A heavy API is harder
* to maintain and implement, therefore we can implement optional operations as extension functions.
* Kotlin does this with the `Sequence` API. All operations like fold, map, reduce, group are implemented as extension
* functions and the base API only provides an `iterator` method.
*
* Other use case for extension method is to bridge external framework classes with our own code, instead of having
* helper static methods.
*
* The extension syntax is `fun Receiver.funName(ParamType): ReturnType`.
* */
fun Any.printMe() {
    println(this)
}
/*-------- Scope functions
* Lastly, scope function are just functions defined in the standard library that use the above features to
* make our life easier.
*
* They are called scope functions because they define a very small scope in where they manipulate the receiver,
* input parameters or return types of an object.
*
* |Function |Receiver   |Parameter  |Return |
* |run      |N/A        |N/A        |R      |
* |with     |T          |N/A        |R      |
* |apply    |T          |N/A        |Unit   |
* |also     |N/A        |T          |T      |
* |let      |N/A        |T          |R      |
*
* All of them are defined in the file `Standard.kt`.
* */
